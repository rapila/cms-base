<?php
/**
 * @package utils
 */
class BuildHelper {
	const CLASSNAME_PATTERN = "/<table[^>]*phpName=\"(\w+)\"/";
	const SCHEMA_FILE_PATTERN = '/(.+\\.)?schema\\.xml/';
	
	public static $PEER_SUFFIX = "Peer";
	public static $MAP_SUFFIX;
	public static $QUERY_SUFFIX = "Query";
	public static $BASE_PREFIX = "Base";
	
	private static function init() {
		self::$MAP_SUFFIX = defined("Propel::VERSION") && version_compare(Propel::VERSION, "1.3", ">=") ? "TableMap" : "MapBuilder";
	}

	public static function preMigrate() {
		self::preBuild();
		self::generateBuildXml();
		self::convertLegacyMigrationTable();
	}

	public static function postMigrate() {
		self::init();
		self::deleteUnusedFiles();
		Cache::clearAllCaches();
	}

	public static function consolidateMigrations($sPart = 'base') {
		$aPaths = explode('/', $sPart);

		foreach(ResourceFinder::create($aPaths)->mainOnly()->addPath('data', 'migrations')->addExpression('/\.php$/')->all()->returnObjects()->find() as $oMigration) {
			print "Copying migration {$oMigration->getFileName()} from $sPart\n";
			copy($oMigration->getFullPath(), MAIN_DIR.'/'.DIRNAME_GENERATED.'/migrations/'.$oMigration->getFileName());
		}
	}
	
	private static function convertLegacyMigrationTable() {
		$oConnection = Propel::getConnection();
		$iCurrentMigration = null;
		try {
			$iCurrentMigration = (int)$oConnection->query('SELECT * FROM `propel_migration`', PDO::FETCH_COLUMN, 0)->fetch();
		} catch(PDOException $e) {
			// Migration table removed already. Nothing to do.
			return;
		}
		if(!$iCurrentMigration) {
			return;
		}
		$aPaths = array_merge(array(DIRNAME_SITE, DIRNAME_BASE), array_keys(ResourceFinder::pluginFinder()->find()));
		foreach($aPaths as $sPath) {
			$sTableName = '_migration_'.str_replace('/', '_', $sPath);
			$oConnection->exec("DROP TABLE IF EXISTS $sTableName");
			$oConnection->exec("CREATE TABLE $sTableName (version int(11) DEFAULT '0')");
			$oConnection->exec("INSERT INTO $sTableName (version) VALUES ($iCurrentMigration)");
		}
		$oConnection->exec("DROP TABLE propel_migration");
	}
	
	public static function preBuild($bIsDevVersion = false) {
		self::init();
		Cache::clearAllCaches();
		self::compileSchemaXml();
		self::copyPropelAdditions();
	}
	
	public static function preOM($bIsDevVersion = false) {
		self::init();
		Cache::clearAllCaches();
		// Nothing to do here… yet
	}
	
	public static function postBuild($bIsDevVersion = false) {
		self::init();
		self::deleteUnusedFiles();
		Cache::clearAllCaches();
	}
	
	public static function postOM($bIsDevVersion = false) {
		self::init();
		self::moveModel($bIsDevVersion);
		Cache::clearAllCaches();
	}
	
	public static function groupedSchemaXml() {
		$aSchemas = array();
		$aSchemaFiles = ResourceFinder::create(array(DIRNAME_CONFIG))->addExpression(self::SCHEMA_FILE_PATTERN)->noCache()->all()->returnObjects()->find();
		foreach($aSchemaFiles as $oSchemaFile) {
			$sSchemaName = self::schemaNameFromFileBasename($oSchemaFile->getFileName('.xml'));
			if(!isset($aSchemas[$sSchemaName])) {
				$aSchemas[$sSchemaName] = array();
			}
			$aSchemas[$sSchemaName][] = $oSchemaFile;
		}
		return $aSchemas;
	}
	
	private static function compileSchemaXml() {
		$sSchemaTemplate = <<<EOT
<?xml version="1.0" encoding="UTF-8"?>
<!-- {{comment}} -->
<database name="{{name}}" defaultIdMethod="native">
	{{schema_content}}
</database>
EOT;

		foreach(self::groupedSchemaXml() as $sSchemaName => $aSchemas) {
			$oSchemaTemplate = new Template($sSchemaTemplate, null, true);
			$oSchemaTemplate->replaceIdentifier('comment', "This file is generated by the generate-model.sh script, edit schema.xml in the config dir or the plugins or site's schema.xml file instead", null, Template::NO_HTML_ESCAPE);
			$oSchemaTemplate->replaceIdentifier('name', $sSchemaName);
			foreach($aSchemas as $oSchemaFile) {
				$oSchemaTemplate->replaceIdentifierMultiple('schema_content', file_get_contents($oSchemaFile->getFullPath()), null, Template::NO_HTML_ESCAPE);
			}
			$sSchemaOutputPath = MAIN_DIR.'/'.DIRNAME_GENERATED."/$sSchemaName.schema.xml";
			file_put_contents($sSchemaOutputPath, $oSchemaTemplate->render());
		}
	}

	public static function generateBuildXml() {
		$aConfiguration = array('propel' => Propel::getConfiguration());
		$oDoc = new DOMDocument();
		$oRoot = $oDoc->createElement('config');
    $oDoc->appendChild($oRoot);
		self::writeConfiguration($oDoc, $aConfiguration, $oRoot);
		$sConfigOutputPath = MAIN_DIR.'/'.DIRNAME_GENERATED.'/buildtime-conf.xml';
		file_put_contents($sConfigOutputPath, $oDoc->saveXML());
	}

	private static function writeConfiguration($oDoc, &$aConfig, $oElement) {
		foreach($aConfig as $sKey => &$mValue) {
			if(is_array($mValue)) {
				$oInner = null;
				if($oElement->tagName === 'datasources') {
					$oInner = $oDoc->createElement('datasource');
					$oInner->setAttribute('id', $sKey);
				} else {
					$oInner = $oDoc->createElement($sKey);
				}
				$oElement->appendChild($oInner);
				self::writeConfiguration($oDoc, $mValue, $oInner);
			} else {
				if(is_bool($mValue)) {
					$mValue = BooleanParser::stringForBoolean($mValue);
				}
				$oAttr = $oDoc->createElement($sKey);
				$oAttr->appendChild($oDoc->createTextNode((string) $mValue));
				$oElement->appendChild($oAttr);
			}
		}
	}
	
	public static function copyPropelAdditions() {
		$sAdditionsOutputPath = MAIN_DIR.'/'.DIRNAME_GENERATED.'/propel_additions';
		if(!file_exists($sAdditionsOutputPath)) {
			mkdir($sAdditionsOutputPath);
		}
		$aBuildClasses = ResourceFinder::findResourceObjectsByExpressions(array(DIRNAME_LIB, 'propel_additions', '/^[\\w_]+\.php$/'));
		foreach($aBuildClasses as $oAddition) {
			$sNewPath = "$sAdditionsOutputPath/".$oAddition->getFileName();
			print "Copying propel addition ".$oAddition->getFileName()." to $sNewPath\n";
			copy($oAddition->getFullPath(), $sNewPath);
		}
	}
	
	public static function getDBAdapter() {
		return Settings::getSetting('database', 'adapter', 'mysql', 'db_config');
	}

	/**
	* Moves the model files of modules to that module’s directory. Called by the generate-model.sh script
	*/
	private static function moveModel($bIsDevVersion = false) {
		$aModelInfo = array();
		foreach(self::groupedSchemaXml() as $sSchemaName => $aSchemas) {
			$aSchemas = array_reverse($aSchemas);
			$bHasSiteSchema = false;
			$bHasPluginSchemas = false;
			$aModelInfo[$sSchemaName] = new StdClass();
			$aModelInfo[$sSchemaName]->didMoveBase = false;
			foreach($aSchemas as $oSchemaFile) {
				if($oSchemaFile->isPlugin()) {
					// Always move model to plugins in dev builds (because site schemas shouldn’t interfere with plugin schemas; we need to change this behaviour if we ever do that)
					$bShouldMoveFiles = $bIsDevVersion;
					$bHasPluginSchemas = true;
				} else if($oSchemaFile->isSite()) {
					// Always move model files to site folder from generated
					$bShouldMoveFiles = true;
					$bHasSiteSchema = true;
				} else {
					// Be safe: only build for base if schema files were neither found in site nor in any plugins.
					// Also, the user must specifically have requested a “dev” build
					// $bHasSiteSchema and $bHasPluginSchemas are always correctly set here because we `array_reverse`d the normal order (which is: base, plugins site)
					$bShouldMoveFiles = $bIsDevVersion && !$bHasSiteSchema && !$bHasPluginSchemas;
					$aModelInfo[$sSchemaName]->didMoveBase = $bShouldMoveFiles;
					print "NOT moving base {$oSchemaFile->getFileName()} model because it’s polluted by plugin or site models\n";
				}
				self::moveModelForSchemaPath($oSchemaFile->getFullPath(), $bShouldMoveFiles); //Always rid `generated` of stuff belonging to `site`
			}
		}
		// Copy generated SQL files to base
		$aSQL = ResourceFinder::findResourceObjectsByExpressions(array(DIRNAME_GENERATED, str_replace('.xml', '.sql', self::SCHEMA_FILE_PATTERN)), ResourceFinder::SEARCH_MAIN_ONLY);
		foreach($aSQL as $oSQLFile) {
			$sSchemaName = self::schemaNameFromFileBasename($oSQLFile->getFileName('.sql'));
			if(isset($aModelInfo[$sSchemaName]) && $aModelInfo[$sSchemaName]->didMoveBase) {
				$sPath = BASE_DIR.'/'.DIRNAME_DATA.'/sql/'.self::getDBAdapter();
				if(!file_exists($sPath)) {
					mkdir($sPath, 0777, true);
				}
				copy($oSQLFile->getFullPath(), "$sPath/{$oSQLFile->getFileName()}");
			}
		}
		return $aModelInfo;
	}
	
	private static function moveModelForSchemaPath($sSchemaPath, $bIsDevVersion) {
		if($bIsDevVersion) {
			$sNewModelDir = dirname(dirname($sSchemaPath))."/".DIRNAME_LIB;
			if(!is_dir($sNewModelDir)) {
				mkdir($sNewModelDir);
			}
			$sNewModelDir = $sNewModelDir."/".DIRNAME_MODEL;
			if(!is_dir($sNewModelDir)) {
				mkdir($sNewModelDir);
			}

			$sNewModelBaseDir = "$sNewModelDir/om";
			if(!is_dir($sNewModelBaseDir)) {
				mkdir($sNewModelBaseDir);
			}

			$sNewModelMapDir = "$sNewModelDir/map";
			if(!is_dir($sNewModelMapDir)) {
				mkdir($sNewModelMapDir);
			}
		}

		$sSchema = file_get_contents($sSchemaPath);
		preg_match_all(self::CLASSNAME_PATTERN, $sSchema, $aMatches);
		$aMatches = $aMatches[1];
		foreach($aMatches as $sClassName) {
			$sClassPath = ResourceFinder::findResource(array(DIRNAME_GENERATED, DIRNAME_MODEL, "$sClassName.php"), ResourceFinder::SEARCH_MAIN_ONLY);
			$sPeerClassPath = ResourceFinder::findResource(array(DIRNAME_GENERATED, DIRNAME_MODEL, "${sClassName}".self::$PEER_SUFFIX.".php"), ResourceFinder::SEARCH_MAIN_ONLY);
			$sQueryClassPath = ResourceFinder::findResource(array(DIRNAME_GENERATED, DIRNAME_MODEL, "${sClassName}".self::$QUERY_SUFFIX.".php"), ResourceFinder::SEARCH_MAIN_ONLY);

			$sBaseClassPath = ResourceFinder::findResource(array(DIRNAME_GENERATED, DIRNAME_MODEL, 'om', self::$BASE_PREFIX."$sClassName.php"), ResourceFinder::SEARCH_MAIN_ONLY);
			$sBasePeerClassPath = ResourceFinder::findResource(array(DIRNAME_GENERATED, DIRNAME_MODEL, 'om', self::$BASE_PREFIX."${sClassName}".self::$PEER_SUFFIX.".php"), ResourceFinder::SEARCH_MAIN_ONLY);
			$sBaseQueryClassPath = ResourceFinder::findResource(array(DIRNAME_GENERATED, DIRNAME_MODEL, 'om', self::$BASE_PREFIX."${sClassName}".self::$QUERY_SUFFIX.".php"), ResourceFinder::SEARCH_MAIN_ONLY);

			//No editable version of the map class exists
			$sMapClassPath = ResourceFinder::findResource(array(DIRNAME_GENERATED, DIRNAME_MODEL, 'map', "${sClassName}".self::$MAP_SUFFIX.".php"), ResourceFinder::SEARCH_MAIN_ONLY);

			if($bIsDevVersion) {
				//Over-writable by the user
				self::moveOverridableFile($sClassPath, $sClassName, $sNewModelDir);
				self::moveOverridableFile($sPeerClassPath, $sClassName, $sNewModelDir, self::$PEER_SUFFIX);
				self::moveOverridableFile($sQueryClassPath, $sClassName, $sNewModelDir, self::$QUERY_SUFFIX);

				//Not over-writable by the user (allow to re-generate)
				self::moveNonOverridableFile($sBaseClassPath, $sClassName, $sNewModelBaseDir);
				self::moveNonOverridableFile($sBasePeerClassPath, $sClassName, $sNewModelBaseDir, self::$PEER_SUFFIX);
				self::moveNonOverridableFile($sBaseQueryClassPath, $sClassName, $sNewModelBaseDir, self::$QUERY_SUFFIX);

				self::moveNonOverridableFile($sMapClassPath, $sClassName, $sNewModelMapDir, self::$MAP_SUFFIX);
			} else {
				// Remove all overridables and leave non-overridables (Base…) in `generated` to be included
				if($sClassPath) {
					unlink($sClassPath);
				}
				if($sPeerClassPath) {
					unlink($sPeerClassPath);
				}
				if($sQueryClassPath) {
					unlink($sQueryClassPath);
				}
			}
		}
	}
	
	private static function moveOverridableFile($sPath, $sClassName, $sDestination, $sSuffix = "") {
		$sClassName = "$sClassName$sSuffix.php";
		$sClass = "$sDestination/$sClassName";
		if(!file_exists($sClass)) {
			print "Moving user-modifiable $sClassName to $sDestination\n";
			rename($sPath, $sClass);
		} else {
			print "[Deleting generated $sClassName because user-modified version exists]\n";
			unlink($sPath);
		}
	}
	
	private static function moveNonOverridableFile($sPath, $sClassName, $sDestination, $sSuffix = "") {
		if($sPath === null || !file_exists($sPath)) {
			return;
		}
		$sClassName = "".($sSuffix == self::$MAP_SUFFIX ? "" : self::$BASE_PREFIX)."$sClassName$sSuffix.php";
		$sClass = "$sDestination/$sClassName";
		if(file_exists($sClass)) {
			unlink($sClass);
		}
		print "Moving generated $sClassName to $sDestination\n";
		rename($sPath, $sClass);
	}
	
	/**
	* Delete temp files only used while running generate-model
	*/
	private static function deleteUnusedFiles() {
		if(file_exists(MAIN_DIR.'/'.DIRNAME_GENERATED.'/buildtime-conf.xml')) {
			unlink(MAIN_DIR.'/'.DIRNAME_GENERATED.'/buildtime-conf.xml');
		}
		// Unlink *.schema.sql files
		$aSchemas = ResourceFinder::findResourceObjectsByExpressions(array(DIRNAME_GENERATED, self::SCHEMA_FILE_PATTERN), ResourceFinder::SEARCH_MAIN_ONLY);
		foreach($aSchemas as $oSchema) {
			$oSchema->unlink();
		}
		// Unlink copied build.properties
		unlink(MAIN_DIR.'/'.DIRNAME_GENERATED.'/build.properties');
		// Unlink copied propel additions (behaviours)
		$aAdditions = ResourceFinder::findResourceObjectsByExpressions(array(DIRNAME_GENERATED, 'propel_additions', '/^[\\w_]+\.php$/'), ResourceFinder::SEARCH_MAIN_ONLY);
		foreach($aAdditions as $oAddition) {
			$oAddition->unlink();
		}
	}
	
	/**
	* Returns the schema name for the base name of a file belonging to the schema.
	* So if you have a file like test.schema.xml or test.schema.sql, pass test.schema, if you have schema.xml or schema.sql, pass schema.
	* It will return the part before .schema or "rapila" if no such part exists.
	*/
	private static function schemaNameFromFileBasename($sFileBasename) {
		if($sFileBasename === 'schema') {
			return 'rapila';
		}
		return substr($sFileBasename, 0, -strlen('.schema'));
	}
}
